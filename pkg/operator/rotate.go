package operator

import (
	"crypto/rsa"
	"crypto/x509"
	"fmt"
	"time"

	"github.com/openshift/library-go/pkg/crypto"
	"github.com/openshift/service-ca-operator/pkg/operator/util"
)

const signingCertificateLifetimeInDays = 365 // 1 year

type signingCA struct {
	config             *crypto.TLSCertificateConfig
	bundle             []*x509.Certificate
	intermediateCACert *x509.Certificate
}

// getPEMBytes returns PEM-encodings of the CA cert, key, bundle and intermediate CA cert.
func (ca *signingCA) getPEMBytes() ([]byte, []byte, []byte, []byte, error) {
	caPEM, keyPEM, err := ca.config.GetPEMBytes()
	if err != nil {
		return nil, nil, nil, nil, err
	}
	bundlePEM, err := crypto.EncodeCertificates(ca.bundle...)
	if err != nil {
		return nil, nil, nil, nil, err
	}
	intermediatePEM, err := crypto.EncodeCertificates(ca.intermediateCACert)
	if err != nil {
		return nil, nil, nil, nil, err
	}
	return caPEM, keyPEM, bundlePEM, intermediatePEM, nil
}

// rotateSigningCA creates a new signing CA, bundle and intermediate CA that together can
// be used to ensure that serving certs generated both before and after rotation can be
// trusted by both refreshed and unrefreshed consumers.
func rotateSigningCA(currentCACert *x509.Certificate, currentKey *rsa.PrivateKey) (*signingCA, error) {
	// Generate a new signing cert
	newCAConfig, err := crypto.MakeSelfSignedCAConfigForSubject(currentCACert.Subject, signingCertificateLifetimeInDays)
	if err != nil {
		return nil, err
	}
	newCACert := newCAConfig.Certs[0]

	// Generate an intermediate cert bridging trust between the new CA and serving certs
	// generated by the current CA for inclusion in the new CA bundle. This will ensure
	// that clients with a post-rotation ca bundle will be able to trust pre-rotation
	// serving certs.
	currentCACertSignedByNewCA, err := createIntermediateCACert(currentCACert, newCACert, newCAConfig.Key.(*rsa.PrivateKey))
	if err != nil {
		return nil, fmt.Errorf("failed to create intermediate certificate: %v", err)
	}

	bundle := []*x509.Certificate{
		newCACert,
		currentCACertSignedByNewCA,
	}

	// Generate an intermediate cert bridging trust between the current CA and serving
	// certs generated by the new CA. This cert will need to be included with serving
	// certs generated by the new CA to ensure that clients with the pre-rotation ca
	// bundle will be able to trust post-rotation serving certs.
	newCACertSignedByOldCA, err := createIntermediateCACert(newCACert, currentCACert, currentKey)
	if err != nil {
		return nil, fmt.Errorf("failed to create intermediate certificate: %v", err)
	}

	return &signingCA{
		config:             newCAConfig,
		bundle:             bundle,
		intermediateCACert: newCACertSignedByOldCA,
	}, nil
}

// createIntermediateCACert creates a new intermediate CA cert from a template provided by
// the target CA cert and issued by the signing cert. This ensures that certificates
// issued by the target CA can be trusted by clients that trust the signing CA.
func createIntermediateCACert(targetCACert, signingCACert *x509.Certificate, signingKey *rsa.PrivateKey) (*x509.Certificate, error) {
	// Copy the target cert to allow modification.
	template, err := x509.ParseCertificate(targetCACert.Raw)
	if err != nil {
		return nil, fmt.Errorf("Failed to copy ca certificate: %v", err)
	}
	// Enable key identity chaining
	template.AuthorityKeyId = signingCACert.SubjectKeyId

	caCert, err := util.CreateCertificate(template, signingCACert, targetCACert.PublicKey, signingKey)
	if err != nil {
		return nil, fmt.Errorf("error creating intermediate CA certificate: %v", err)
	}

	return caCert, nil
}

// certHalfwayExpired indicates whether half of the cert validity period has elapsed.
func certHalfwayExpired(cert *x509.Certificate) bool {
	halfValidPeriod := cert.NotAfter.Sub(cert.NotBefore).Nanoseconds() / 2
	halfExpiration := cert.NotBefore.Add(time.Duration(halfValidPeriod) * time.Nanosecond)
	return time.Now().After(halfExpiration)
}
